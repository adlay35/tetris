# 테트리스 규칙

1. 가로 10, 세로 20칸 게임판
2. 4가지 블럭으로 이루어진 전체 7가지 블럭
3. 블럭은 좌 우로 90도씩 회전 가능하며 한칸씩 이동가능
4. 블럭은 시간이 흐름에 따라 자동으로 하강함
5. 블럭이 더이상 내려갈수 없다면 그 위치에 고정됨
6. 블럭 고정후, 가로줄이 빈틈 없이 채워진다면 그 줄은 사라지고, 위에 고정되어있던 블럭들이 내려옴
7. 새로 생성된 블록이 게임판의 가장 위쪽에 있는 이미 쌓인 블록 때문에 시작 위치에 놓일 수 없을 때 게임이 종료됨

---

# 파일 구조

main.py     // 게임 실행 관리  
board.py    // 게임판 데이터, 블록 고정과 줄 지우기  
tetromino.py    // 블록 모양 데이터, 이동과 회전, 충돌검사  
display.py      // 화면 출력  
input_handler.py  // 사용자 입력처리  

---

# 윈도우 분리
### curses 윈도우 객체를 총 3개로 분리함.  
1. border_window: 게임 보드의 외곽선 (벽)
2. active_piece_window: 움직이고 있는 블럭
3. playing_field_window: 이미 고정된 블럭들과 게임보드의 빈 공간

1번 윈도우는 초기에만 그리고 건드리지 않음  
2~3번 윈도우는 각각의 조건을 만족시킬때만 새로고침하며 최대한 깜박이는 효과를 줄이기

---

# 게임 루프

```text
게임 보드 초기화  
border_window 출력  

main loop {  
    이전에 출력되었던 블럭 위치의 색을 지움

    사용자 입력감지     // 이동, 회전 계산 -> 블럭 충돌 계산
    블럭 자동 하강      // + 블럭 충돌 계산

    // 블럭이 게임 보드의 최하단 혹은 고정된 블럭과 충돌
    if (블럭 고정이 감지된 경우) {
        움직이던 블럭을 고정 처리

        if (가로 한줄이 완성된 경우) {
            해당 라인 삭제
            위에 있는 모든 고정된 블럭들을 1줄씩 하강

            // 라인 삭제 및 고정된 블록들의 하강을 반영
            playig_field_window.refresh()
        }

        if (고정된 블럭이 최상단에 닿는 경우) {
            게임 오버
        }

        새로운 블럭 생성
    }

    if (블럭 고정이 감지되지 않은 경우) {
        // 게임 보드의 데이터 변화 X, 이동한 블럭의 이전 위치를 지움
        playing_field_window.refresh()

        움직인 블록을 새로운 위치에 그리기

        active_piece_window.refresh()
    }


}
```

